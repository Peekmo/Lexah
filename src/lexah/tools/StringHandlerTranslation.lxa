-- vim: set ft=rb:
module lexah.tools

class StringHandle

@:[public] var content: String
@:[public] var position: Int
@:[public] var current: String
@:[public] var tokens: Array<String>

def new(content: String, ?tokens: Array<String>, position: Int = 0)
    @content = content

    if tokens == null then
        @tokens = ["\n"]
    else
        @tokens = tokens
    end

    @position = position
end

--*
    Reset position and text
*--
def reset() : Void
    @position = 0
    @current = null
end

--*
    Check if we are in the beginning of @current
*--
def atStart() : Bool
    return @position <= 0
end

--*
    Check if we are in the end of @current
*--
def atEnd() : Bool
    return @position >= @content.length
end

--*
    Check if we are in near the beginning of @current
*--
def nearStart(tolerance: Int) : Bool
    return (@position - tolerance) <= 0
end

--*
    Check if we are in near the end of @current
*--
def nearEnd(tolerance: Int) : Bool
    return (@position + tolerance) > @content.length
end

--*
    Go to the closest token
*--
def closest(content: String): Bool
    var divided = @divided();
    var regex = new EReg("[^\\w][ \t]*" + content, "")
    var sub = @content.substr(@position)

    var count = 1
    while true do
        if sub.charAt(count) == " "
        or sub.charAt(count) == "\t"
        or sub.charAt(count) == "\n" then
            count++
        else
            break
        end
    end

    return regex.match(sub.substr(0, count))
end

--*
    Checks if the current is the content
*--
def is(content: String): Bool
    return @current == content
end

--*
    Checks if the current is in the given array
*--
def isOne(content: Array<String>): Bool
    var contains = false

    for cnt in content do
        contains = contains || @current == cnt
    end

    return contains
end

--*
    Token started by whitespace
*--
def safeisStart(content: String): Bool
    var regex = new EReg("[^\\w]" + content, "")

    if @nearStart(1) then
        return @is(content)
    end

    if @nearEnd(content.length + 1) then
        return @is(content)
    end

    var sub = @content.substr(
        @nearStart(1) ? @position : @position - 1,
        @nearEnd(@content.length + 1) ? @content.length : @content.length + 1
    )

    return regex.match(sub)
end

--*
    Splits the text in 2 parts
*--
def divided(?offset: Int = 0)
    return {
        left: (@position + offset) > 0
            ? @content.substr(0, @position + offset)
            : "",
        right: (@position + offset) < @content.length
            ? @content.substring(@position + offset)
            : ""
    }
end
